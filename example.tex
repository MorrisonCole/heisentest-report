\section{Example}
\label{sec:example}

\Flaky tests tend to occur on the system level. They do not often manifest in
unit or integration tests since these tests usually simply call a function with
some parameters and check its output against some expected value in isolation
from the system as a whole (or, in the case of integration - against some
external service). Acceptance tests, on the other hand, target the application
in its entirety. Developers of software for mobile Operating Systems such as
Android employ test runner instrumentation frameworks to simulate user input and
check for the presence of elements in the user interface. Later, we discuss the
application of our proof of concept tool on a test suite made up of exactly
these kind of tests. First, we use this section to explain informally what a
flaky test may look like in practice.

Essentially, any test can be distilled down to three basic steps:
\textit{arrange}, \textit{act} and \textit{assert}. A well-written test may read
similarly to the following:
\begin{verbatim}
  Given I am in state X (arrange)
  When I do perform action A (act)
  Then I am in state Y (assert)
\end{verbatim}

\Flaky tests are commonly caused by timing issues. Considering the general
outline above, it is obvious that the act step requires the arrange step to have
completed before it runs --- there must be some kind of wait and check mechanism
to block further progress until the arrange step has finished.

As an example, consider a test run that initially enters state $X$
(arrange), where $X$ is a vector $(x_{1}, x_{2}, x_{3})$. Action $A$
transforms $X$ to $Y$: $(y_{1}, y_{2}, y_{3})$. Finally, the assertion
checks that the current state is equal to $Y$.

If each value of the vector $X$ is loaded asynchronously, the test must
check for each of the vector values to be correct before $A$ is applied. If the
test checked only the first two values, the action would complete only if the
third element happened to have loaded before the values in position 1 and 2.

In practice, with hundreds of user interface elements, these types of problems
can become quite prevalent. Often, the solutions are obvious, but sometimes
there is not enough information to solve the problem from the regular test
results, especially if the failure is rare.
