\section{Example}
\label{sec:example}

\Flaky tests tend to occur on the system level. They do not often manifest in
unit or integration tests since these tests usually simply call a function with
some parameters and check its output against some expected value in isolation
from the system as a whole (or, in the case of integration - against some
external service).

Acceptance tests, on the other hand, target the software as a whole. Developers
of software for mobile Operating Systems employ instrumentation to simulate user
input and check for the presence of elements in the user interface. Essentially,
a test can be distilled down to:
\begin{verbatim}
  Given I am in this state (arrange)
  When I do this (act)
  Then I am in this state (assert)
\end{verbatim}

\Flaky tests are commonly caused by timing issues. The action step requires the
arrange step to have completed before it runs; there must be some kind of wait
and check mechanism to block further progress until the arrange step has
finished.

For example, consider a test run that initially enters state $S_{1}$ (arrange),
where $S_{1}$ is a vector $(x_{1},x_{2},x_{3})$. Action $A$ transforms $S_1$ to
$S_2$ --- $(x_{1},x_{2},x_{3})$. Finally, the assertion checks that the current
state is equal to $S_2$.

If each value of the vector $S_{1}$ is loaded asynchronously, the test must
check for each of the vector values to be correct before $A$ is applied. If the
test checked only the first two values, the action would complete only if the
third element happened to have loaded before the values in position 1 and 2.

In practice, with hundreds of user interface elements, these types of problems
can become quite prevalent. Often, the solutions are obvious, but sometimes
there is not enough information to solve the problem.
