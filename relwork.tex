\section{Related Work}
\label{sec:relwork}

Adaptive Bug Isolation \cite{ArumugaNainar:2010:ABI:1806799.1806839} and other
bug isolation papers have taken a conservative approach to information
gathering. Each of the previous frameworks have targeted production
environments, so privacy and performance were major concerns. The environment
we operate in is ideal in comparison. We do not suffer many of the limitations
found in past work. This section compares our framework to previous work in
terms of environment.

\subsubsection{Ordering}

In previous statistical bug isolation projects, event ordering is completely
discarded due to privacy concerns; recording a play-by-play execution is
invasive to the common user. Since our instrumentation will run in a development
environment, there are no user concerns --- the tests are automated. We can
maintain ordering with the small penalty of increased overhead.

Multi-threaded environments are commonplace. In order to record the execution
order of multiple threads, we include the system time in each log event. Each
thread logs to a separate location. After the test run completes, we merge and
interleave the individual logs before storing them. We end up with a single log
with the original ordering intact.

\subsubsection{Data Collection and Storage}

Again, our context allows for more flexibility. In production systems, logs have
to be stored on user devices and transferred to a central location for analysis.
Storing logs and sending them across the network is expensive in terms of user
disk space and bandwidth, so these aspects are minimised in previous work. In
our case, tests are run internally on project-owned machines and devices. Log
files can be transferred to the central database immediately following a test
run. Each test run requires a clean device by definition, so devices will almost
certainly never run out of space for log storage.

The only real storage concern is that of the central database. But, this can be
managed effectively by limiting the number of historical test run logs to keep
--- much in the same way Jenkins and other Continuous Integration tools do by
default.

\subsubsection{Performance}

Instrumentation adds performance overhead. In the case of a production system,
this is a major problem since performance directly affects a user's experience.
Previous approaches have therefore aimed for minimal overhead: Nainar and
Liblit's \cite{ArumugaNainar:2010:ABI:1806799.1806839} Adaptive Bug Isolation
system has a performance overhead of just 1\%.

In a test environment, smoothness and load times rarely matter. Of course, there
are exceptions (performance regression tests, etc.), but we expect to mainly be
dealing with system tests. We can safely add instrumentation and ignore
performance, so long as we remain within budget.

\subsubsection{Adaptivity}

Both fixed \cite{Liblit:2003:BIV:781131.781148} \cite{NIPS2003_AP05}
\cite{ArumugaNainar:2007:SDU:1273463.1273467}
\cite{Andrzejewski:2007:SDU:1421665.1421672}
\cite{Parsa:2011:SDU:2045625.2045659} and adaptive
\cite{ArumugaNainar:2010:ABI:1806799.1806839} approaches have been proposed in
the past. All of these approaches were developed with the underlying constraint
of deploying the instrumented software to real users.
\cite{ArumugaNainar:2010:ABI:1806799.1806839} makes use of binary
instrumentation to iteratively re-instrument deployed applications to hone in on
bug-predicting predicates. Whilst the adaptive approach has many benefits in
terms of overhead, it relies on a specialized API --- Dyninst \cite{dyninst} ---
for code patching to support the injection of instrumentation at runtime. This
has additional runtime costs \cite{DyninstGuide} associated with saving and
restoring registers and performing protective checks not present in a fixed
instrumentation.

Again, our context allows more freedom. Every test run requires a new build by
nature, so we can simply apply a unique fixed instrumentation every time. In
other words, we retain the optimisation benefits of a fixed instrumentation
whilst gaining those of the adaptive solution.
